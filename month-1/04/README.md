## Разбор уязвимостей OWASP Top 10 - REST API

### I. Теоретическая часть.

|      CVE       | Категория                                       | Описание                                                     |
| :------------: | ----------------------------------------------- | ------------------------------------------------------------ |
| CVE-2022–35909 | API2:2019 — Broken authentication               | В Jellyfin до версии 10.8 конечная точка /users имеет неправильный контроль доступа к функциям администратора. Путем изменения идентификатора, который сохранялся даже после выхода из системы, была возможность доступа к панели администратора непривилегированному пользователю путем подмены этого идентификатора. Причина - в неаккуратности программистов, забывших изменить политику доступа в классе по умолчанию, реализующем функционал доступа к репозиториям. |
| CVE-2023-27474 | API8:2019 — Injection                           | Directus - это API в реальном времени и панель управления приложениями для управления содержимым базы данных SQL. Экземпляры, использующие URL-адрес сброса, указанный в списке разрешенных, уязвимы для атаки с использованием HTML-инъекций из-за использования параметров запроса в URL-адресе сброса. Злоумышленник может использовать это для отправки пользователям URL-адресов электронной почты на домен servers, но которые могут содержать вредоносный код. Причина - ошибка проектирования. |
| CVE-2023-28645 | API5:2019 — Broken function level authorization | Nextcloud richdocuments - это приложение Nextcloud, интегрирующее онлайн-Collabora office suit. В затронутых версиях функцию безопасного просмотра приложения rich documents можно обойти, используя незащищенную внутреннюю конечную точку API приложения rich documents. Рекомендуется обновить приложение Nextcloud Office (richdocuments) до версии 8.0.0-beta.1, 7.0.2 или 6.3.2. Настоятельно рекомендуется определить список IP-адресов сервера Collabora в качестве разрешенного списка в настройках администратора Office в Nextcloud. Причина - ошибка проектирования. |



### II. Практическая часть.

#### Подготовка тестового стенда.

Для запуска тестового стенда запустим скрипт **run.sh**:

```bash
docker pull ket9/otus-devsecops-owasp-rest
docker run -d -p 8080:8080 --name otus-05 ket9/otus-devsecops-owasp-rest:latest
while ! nc -z localhost 8080; do
  sleep 0.1
done
curl http://localhost:8080/createdb
```


Этот скрипт скачает образ, запустит его и сформирует базу данных:

![01](./images/service_start.png)


------

#### Исследования сервиса.

Для начала проверим, как сервис обрабатывает несуществующие ссылки:

![process_incorrect_url](./images/process_incorrect_url.png)

Как видим, обработка такой ошибки выполнена. Однако в ответе есть странное поле: `type: abount:blank`. Так как обработка отсутствующих ссылок обычно возлагается на фреймворк, то попробуем найти, какой фреймворк подставляет такое поле в свой ответ в ошибках, которые обрабатывает он сам. Мы знаем, что сервер написан на python из заголовков ответа сервера:

![server_response_headers](./images/server_response_headers.png)

Первая же строка поиска в Google нам говорит, что это может быть фреймворк [connexion](https://github.com/spec-first/connexion).

![google_search_framework](./images/google_search_framework.png)

Мы можем проверить, действительно ли это так, попробовав открыть спецификации сервиса по ссылке по умолчанию: http://localhost:8080/ui/ 

Как видим, открылась документация Swagger, в которой перечислены все поддерживаемые методы.

![08](./images/swagger-ui.png)

Определим версию swagger-ui, указав в консоли браузера команду:

`JSON.stringify(versions)`

Полученный ответ:

```json
{"swaggerUi":{"version":"3.52.0","gitRevision":"gee40b00","gitDirty":true,"buildTimestamp":"Mon, 09 Aug 2021 15:13:17 GMT","machine":"ip-XXX-XX-XX-XXX"}}
```

Попробуем найти уязвимости, связанные с этой версией:

https://security.snyk.io/vuln/SNYK-JS-SWAGGERUI-2314885

Эта уязвимость говорит нам о том, что злоумышленник может как минимум исказить предоставляемую информацию, подгрузив ее с внешнего ресурса, указав адрес в ссылке.

http://localhost:8080/ui/?configUrl=https://jumpy-floor.surge.sh/test.json

или

http://localhost:8080/ui/?url=https://jumpy-floor.surge.sh/test.yaml

![swagger-exploit](./images/swagger-exploit.png)

Приложение представляет нам две интересующих нас группы эндпойнтов - books и users, будем исследовать их по очереди.

#### Группа USERS

[Документация.](http://localhost:8080/ui/#/users)

Все необходимые сведения о названиях методов, типах полезной нагрузки и именах полей нам теперь известны, так что можем зарегистрировать пользователя. Сначала попробуем регистрацию с некорректными данными:

![incorrect_register_data](./images/incorrect_register_data.png)

Внезапно, но сервис регистрирует пользователя без указания каких-либо данных. То есть как минимум допускается создание аккаунтов с пустыми паролями и не проверяется корректность других входных данных (логично предположить, что как минимум usernaавторизацииme должно быть определено, так как адрес электронной почты может не являться обязательным полем, если не требуется подтверждение регистрации). 

Посмотрим, какие пользователи уже существуют в системе. Для этого нет необходимости авторизоваться, и всю необходимую нам информацию о пользователях нам предоставит метод **_debug:**

![all_users_info](./images/all_users_info.png)

Мы видим всю информацию обо всех зарегистрированных пользователях, включая пароли и адреса электронной почты. Также мы видим не менее интересное поле **admin**, которое судя по всему предоставляет права администратора. Это поле мы попробуем выставить позднее.

Несмотря на то, что мы узнали данные администратора всего за несколько простых шагов, не опираясь на вводную задания о доступности метода **_debug**, будем считать, что этот метод не был доступен, и продолжим исследования.

Зарегистрируем нашего нового пользователя:

```json
Запрос:
{"username": "newuser", "password": "password", "email": "newuser@email.com"}
Ответ:
{"message": "Successfully registered. Login to receive an auth token.", "status": "success"}
```

Теперь попробуем авторизоваться с указанием имени несуществующего пользователя:

```json
Запрос:
{"username": "superuser", "password": "password"}
Ответ:
{"message": "Username does not exist", "status": "fail"}
```

При авторизации без пароля, но с точно существующим именем пользователя:

```json
Запрос:
{"username": "newuser", "password": "incorrect_password"}
Ответ:
{"message": "Password is not correct for the given username.","status": "fail"}
```

Теперь авторизуемся от нашего пользователя:

```json
Запрос:
{"username": "newuser", "password": "password"}
Ответ:
{
    "auth_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2ODE2NzkyOTEsImlhdCI6MTY4MTY3MzI5MSwic3ViIjoibmV3dXNlciJ9.zYW78Q4agEz2bkwOjf1JnHyohXyeqLsUIam1rWCBzI8",
    "message": "Successfully logged in.",
    "status": "success"
}
```

Попробуем посмотреть, что внутри этого токена:

![decoded_jwt_token](./images/decoded_jwt_token.png)

Как видим - ничего особо интересного там нет, кроме имени пользователя и времени создания и истечения токена.

Теперь пробуем выполнить какую-либо операцию, требующую токена, например удаление пользователя по имени, явно требующей прав администратора. В ответ мы получим ошибку:

```json
{
    "status": "fail",
    "message": "Only Admins may delete users!"
}
```

Теперь хотелось бы получить каким-либо образом права администратора. Есть два варианта: поднять уровень прав своему аккаунту, или получить доступ к существующему аккаунту администратора через токен авторизации (вариант с уже известным паролем мы не рассматриваем). Попробуем сначала второй вариант.

Проверим, насколько корректно обрабатывается токен в приложении. Мы видим, что используется алгоритм HS256. Попробуем отключить проверку подписи токена, для чего перекодируем его, указав имя admin, и укажем в поле alg значение **none**, что отключает проверку подписи (CVE-2015-9235).

Новый токен будет иметь вид:
```
eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJleHAiOjE2ODE2NzI5NTYsImlhdCI6MTY4MTY2Njk1Niwic3ViIjoiYWRtaW4ifQ
```

При выполнении операции получаем ошибку:

```json
{
    "status": "fail",
    "message": "Invalid token. Please log in again."
}
```

Если мы добавим в токен пустую подпись, то получим уже более интересную ошибку:

```json
{
    "detail": "The server encountered an internal error and was unable to complete your request. Either the server is overloaded or there is an error in the application.",
    "status": 500,
    "title": "Internal Server Error",
    "type": "about:blank"
}
```

Эта ошибка говорит нам о том, что обработка этой ошибки не была предусмотрена разработчиками приложения, и она была обработана самим фреймворком. То есть если бы авторы фреймворка решили выводить вместе с текстом сообщения какую-либо отладочную информацию (переменные окружения и прочее), то мы бы смогли получить много ценного для нас. Такая же проблема содержится и в запросах, которые должны получать тело запроса при получении пустого значения вместо ожидаемой полезной нагрузки, и в некоторых других местах, например при выполнении запроса типа `http://localhost:8080/users/v1'` 

Теперь проверим методы, которые позволяют изменить пароль и электронную почту. Нас интересует возможность изменить эти данные для любого пользователя, не имея прав администратора, а также проверить, каким образом выполняется проверка входных данных.

Выполним запрос на изменение пароля для пользователя admin (мы знаем, что он существует, так как авторизация с таким логином но неверным паролем нам явно на это указывает)

![change_admin_password](./images/change_admin_password.png)

Ответ сервера говорит нам, что пароль успешно сменен. Убедимся в этом:

![admin_success_login](./images/admin_success_login.png)

Теперь попробуем сменить пароль на пустой:

![change_admin_password_fail](./images/change_admin_password_fail.png)

Как видим, при смене пароля пустой установить уже не удается, в отличие от момента с регистрацией. Смена адреса электронной почты для других пользователей также не удается, что говорит нам о том, что при смене адреса имя пользователя берется из токена, а при смене пароля - из адресной строки.

Теперь проверим, как проверяется корректность адреса электронной почты.

Пробуем разные адреса:

```
newadmin_@admin@org1
newadmin@111._com
newadmin
```

На все попытки получаем одинаковый ответ:

```json
{
    "status": "fail",
    "message": "Please Provide a valid email address."
}
```

Исходя из личного опыта могу предположить, что адрес электронной почты скорее всего проверяется с помощью регулярного выражения, и есть вероятность использования некорректно составленного выражения, которое может привести к тому, что в процессе анализа сервис зависнет (уязвимость regexp denial of service attack). Проверим это, указав в поле email длинную строку:

![email_regexp_problem](./images/email_regexp_problem.png)

В итоге сервис завис на выполнении этой операции, и больше не отвечает ни на один запрос.

Теперь попробуем выполнить удаление пользователя не имея прав администратора.

![delete_user_error](./images/delete_user_error.png)

Не имя прав администратора, выполнить это не удается.

Теперь вернемся к полю admin в параметрах пользователя. Так как не предоставляются методы, с помощью которых это поле может быть изменено, можем предположить, что оно выставляется при регистрации пользователя. Проверим это, выполнив запрос:

```json
{
    "username": "newuser",
    "password": "password",
    "email": "newuser@email.com",
    "admin": true
}
```

Регистрация прошла успешно, но флаг не был установлен. При этом нет описания этого флага в [документации](http://localhost:8080/ui/#/users/api_views.users.register_user), значит нам придется его подбирать. Обычно флаг считается установленным, если он имеет значение true, 1, или некоторое строковое значение, типа "yes", или "True"

Методом перебора значения получаем корректный запрос, который нам зарегистрирует нового администратора.

```json
{
    "username": "newuser",орор
    "password": "password",
    "email": "newuser@email.com",
    "admin": "True"
}
```

![new_admin](./images/new_admin.png)

Регистрация выполнена успешно, и флаг admin у нового пользователя тоже установлен.

#### Группа BOOKS

[Документация](http://localhost:8080/ui/#/books).

Группа предоставляет 3 метода - добавление книги, получение списка книг и сведений по конкретной книге.

Проверим все эти методы сначала без авторизации.

Получим список всех книг:

![all_books](./images/all_books.png)

Сведения получены успешно.

Получим сведения по конкретной книге:

![get_book_error](./images/get_book_error.png)

Судя по ошибке, для получения сведений о конкретной книге должно быть доступно только пользователю, который ее добавил.

Добавление книги также доступно только авторизованным пользователям:

![add_book_error](./images/add_book_error.png)

Попробуем получить доступ к книге другого пользователя, используя свой токен без прав администратора:

![get_book_other_user_ok](./images/get_book_other_user_ok.png)

Как видим, доступ возможен для любого авторизованного пользователя.

Теперь попробуем добавить книгу. Но так как имени пользователя в адресной строке нет, то очевидно владелец книги задается или токеном, или дополнительным полем в полезной нагрузке. В списке книг мы видим, что у каждой записи есть поле user. Попробуем указать его.

![add_book_with_user](./images/add_book_with_user.png)

Книга успешно добавлена. Теперь посмотрим, добились мы интересующего нас результата или нет:

![all_books_after_add](./images/all_books_after_add.png)

Видим что книга добавлена, но не туда куда мы хотели. Попробуем повторить это, но уже используя поле owner, которое мы видели в выводе детальных сведений по книге:

![add_book_with_owner](./images/add_book_with_owner.png)

Книга опять успешно добавлена. Смотрим результат:

![all_books_error](./images/all_books_error.png)

И результат несколько неожиданный - повторное добавление книги полностью вывело из строя методы группы **BOOKS**, кроме добавления новых книг, и просмотра сведений о последней добавленной книге.

Сведем в таблицу итоги нашего исследования:

|      | Уязвимость                                                   | Тип уязвимости                                               | Категория OWASP                                 | Рекомендации по устранению.                                  |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------------------------- | ------------------------------------------------------------ |
| 1    | Использование настроек по умолчанию фреймворка connexion, что приводит к неконтролируемому доступу к конфиденциальной информации | CWE-453: Insecure Default Variable Initialization            | API7:2019 — Security misconfiguration           | В настройках приложения изменить путь к интерфейсу Swagger, по возможности закрыть доступ к нему, например, средствами Nginx (basic auth). |
| 2    | Отсутствует проверка входных данных при регистрации/авторизации пользователя. | CWE-20: Improper Input Validation<br />CWE-521: Weak Password Requirements | API2:2019 — Broken authentication               | Проверка корректности входных данных в имени пользователя, адресе электронной почты и пароле. |
| 3    | Получение полных сведений о пользователях (метод **_debug**) | CWE-200: Exposure of Sensitive Information to an Unauthorized Actor | API5:2019 — Broken function level authorization | Подобные методы не должны предоставлять данные без авторизации - добавить проверку прав авторизованного пользователя. А в идеале отладочные методы должны отсутствовать в общедоступной спецификации. |
| 4    | Возможность определения существования пользователя с конкретным именем при авторизации или регистрации. | CWE-204: Observable Response Discrepancy                     | API3:2019 — Excessive data exposure             | Не давать явного ответа, существует ли пользователь, например всегда отвечать "Неверное имя пользователя или пароль" в случае неверной авторизации, и всегда отвечать об успешности регистрации, если пользователь с таким именем уже существует. |
| 5    | Некорректная обработка исключений                            | CWE-703: Improper Check or Handling of Exceptional Conditions | API7:2019 Security Misconfiguration             | Больше архитектурная проблема. Современные фреймворки в большинстве своем предоставляют возможность контроля над исключениями, которые не были обработаны в бизнес-логике приложения, и [connexion не исключение](https://connexion.readthedocs.io/en/stable/exceptions.html#default-exception-handling). |
| 6    | Возможность смены пароля другого пользователя                | CWE-620: Unverified Password Change                          | API1:2019 — Broken object level authorization   | При смене пароля требовать указания текущего пароля.         |
| 7    | Отказ в обслуживании при смене адреса электронной почты при указании специально подготовленных входных данных | CWE-1333: Inefficient Regular Expression Complexity<br />CWE-400: Uncontrolled Resource Consumption | API4:2019 — Lack of resources and rate limiting | Использование регулярных выражений, не содержащих таких уязвимостей и ограничение длинны входных данных. |
| 8    | Установка прав пользователя при регистрации                  | CWE-269: Improper Privilege Management                       | API6:2019 — Mass assignment                     | Запрет установки уровня прав при регистрации пользователя. Новый пользователь должен получать минимальный набор прав, и в дальнейшем получать новые по необходимости. |
| 9    | Возможность доступа к книге любого пользователя              | CWE-200: Exposure of Sensitive Information to an Unauthorized Actor | API1:2019 — Broken object level authorization   | Вообще не очень ясный момент - возможно разрешение просмотра поля secret разрешено бизнес-логикой. Но мы будем исходить из предположения, что это поле должно быть доступно только пользователю, добавившему книгу.<br />Исправить механизм контроля - имя пользователя брать из токена, а не из адресной строки. |
| 10   | Отказ в обслуживании в ряде методов группы методов BOOKS     | CWE-400: Uncontrolled Resource Consumption                   | API4:2019 — Lack of resources and rate limiting | Исправление логики добавления и отображения книг.            |
| 11   | Использование небезопасного протокола HTTP                   | CWE-523: Unprotected Transport of Credentials                | API7:2019 — Security misconfiguration           | Переход на протокол HTTPS                                    |
| 12   | Отсутствие [рекомендованных](https://owasp.org/www-project-secure-headers/) HTTP-заголовков безопасности и наличие рекомендованных к удалению. | CWE-523: Unprotected Transport of Credentials                | API7:2019 — Security misconfiguration           | Добавить в ответы сервера необходимые заголовки, убрать заголовок Server |
| 13   | Хранение паролей в открытом виде                             | CWE-256: Plaintext Storage of a Password                     | API3:2019 — Excessive data exposure             | Хранение паролей в виде, не допускающем их восстановление (например, в виде хэшей с использованием "соли"). Запрет вывода паролей в  API. |
| 14   | Возможный перехват нажатий пользователей, подмена содержимого документации. | CWE-1021: Improper Restriction of Rendered UI Layers or Frames | API7:2019 — Security misconfiguration           | Обновление swagger-ui до версии минимум 4.1.3                |

